C51 COMPILER V9.52.0.0   PROCESS                                                           08/17/2016 10:12:55 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROCESS
OBJECT MODULE PLACED IN ..\OUT\process.obj
COMPILER INVOKED BY: C:\Program Files\kile\C51\BIN\C51.EXE ..\SRC\process.c LARGE OMF2 BROWSE INCDIR(..\INC;..\PRO;..\SR
                    -C) DEBUG PRINT(.\process.lst) TABS(2) OBJECT(..\OUT\process.obj)

line level    source

   1          #include "include.h"
   2          
   3          /*******************************************************************************
   4                      ¶Ô¶à×Ö½Ú¶ÁÃüÁîÏìÓ¦
   5            input:   none     
   6            output:  none         
   7          *******************************************************************************/
   8          void ACK_Multi_Read(void)
   9          {
  10   1        UINT8 tIndex = 0;
  11   1        UINT8 addr;
  12   1        UINT16 usCRC;
  13   1              
  14   1        addr    = address[0] * 100 + address[1]*10 + address[2];    
  15   1      
  16   1        uart.wBuffer[0] = addr;                         //addr
  17   1        uart.wBuffer[1] = 0x03;                         //function code
  18   1        //¿´×ÓÃüÁî
  19   1        switch(uart.rBuffer[5])
  20   1        {
  21   2          case 0X03:    //¶ÁÈ¡°´Å¥°´ÏÂÐÅÏ¢
  22   2          {
  23   3            uart.wBuffer[2] = 0x01;                         //1 byte
  24   3            if(IsOkPressed)
  25   3              uart.wBuffer[3] = 0x01;                     //Pressed
  26   3            else
  27   3              uart.wBuffer[3] = 0x00;                     //UnPressed
  28   3            uart.wLen       = 4; 
  29   3            break;
  30   3          }
  31   2          case 0X05:    //¶ÁÈ¡É¨ÃèÇ¹
  32   2          {
  33   3            if(RC522_rFlag == ON)
  34   3            {
  35   4              uart.wBuffer[2] = ID_Num;
  36   4              for(tIndex = 0; tIndex < ID_Num; tIndex++)
  37   4                uart.wBuffer[3+tIndex] = g_ucTempbuf[tIndex];
  38   4              uart.wLen = 3+ID_Num;
  39   4            }
  40   3            else     
  41   3            {
  42   4              uart.wBuffer[2] = 0;
  43   4              uart.wLen = 3;
  44   4            }
  45   3            break;
  46   3          }
  47   2          default:
  48   2          {
  49   3            break;
  50   3          }
  51   2        }
  52   1        usCRC = CRC16(uart.wBuffer, uart.wLen);
  53   1        uart.wBuffer[uart.wLen] = (UINT8)usCRC;
  54   1        uart.wBuffer[uart.wLen+1] = (UINT8)(usCRC>>8);
C51 COMPILER V9.52.0.0   PROCESS                                                           08/17/2016 10:12:55 PAGE 2   

  55   1        uart.wLen += 2;                            
  56   1      //    Send485SeriaDate((UINT8 *)g_ucTempbuf, ID_Num);
  57   1        Send485SeriaDate((UINT8 *)uart.wBuffer, uart.wLen); 
  58   1      }
  59          void ACK_Multi_ReadTestAddr(void)
  60          {
  61   1        UINT8 addr;
  62   1        UINT16 usCRC;
  63   1              
  64   1        addr    = address[0] * 100 + address[1]*10 + address[2];    
  65   1      
  66   1        uart.wBuffer[0] = addr;                         //addr
  67   1        uart.wBuffer[1] = 0x03;                         //function code
  68   1        uart.wBuffer[2] = 0x00;                       //Len
  69   1        usCRC = CRC16(uart.wBuffer, 3);
  70   1        uart.wBuffer[3] = (UINT8)usCRC;
  71   1        uart.wBuffer[4] = (UINT8)(usCRC>>8);
  72   1        uart.wLen   = 5;                            
  73   1        Send485SeriaDate((UINT8 *)uart.wBuffer, uart.wLen); 
  74   1      }
  75          /*******************************************************************************
  76                      ¶Ô¶à×Ö½ÚÐ´ÃüÁîÕý³£ÏìÓ¦
  77            input:   none     
  78            output:  none         
  79          *******************************************************************************/
  80          void ACK_Single_Write(void)
  81          {
  82   1        Send485SeriaDate((UINT8 *)uart.rBuffer, uart.rIndex); 
  83   1      }
  84          /*******************************************************************************
  85                      ¶Ô¶à×Ö½ÚÐ´ÃüÁîÕý³£ÏìÓ¦
  86            input:   none     
  87            output:  none         
  88          *******************************************************************************/
  89          void ACK_Multi_Write(void)
  90          {
  91   1        UINT8 addr    = address[0] * 100 + address[1]*10 + address[2];
  92   1        UINT16 usCRC;
  93   1      
  94   1        uart.wBuffer[0] = addr;                         //addr
  95   1        uart.wBuffer[1] = 0x10;                         //function code
  96   1        uart.wBuffer[2] = 0x00;                         //start addr
  97   1        uart.wBuffer[3] = 0x00;
  98   1        uart.wBuffer[4] = 0x00;
  99   1        uart.wBuffer[5] = 0x05;
 100   1      
 101   1        usCRC = CRC16(uart.wBuffer, 6);
 102   1      
 103   1        uart.wBuffer[6] = (UINT8)usCRC;
 104   1        uart.wBuffer[7] = (UINT8)(usCRC>>8);
 105   1      
 106   1        uart.wLen        = 8; 
 107   1        Send485SeriaDate((UINT8 *)uart.wBuffer, uart.wLen); 
 108   1      }
 109          /*******************************************************************************
 110            input:   none     
 111            output:  none         
 112          *******************************************************************************/
 113          void ResetAddr(void)
 114          {
 115   1        //ÏÔÊ¾Çå³ý,Êý¾Ý¸´Î»
 116   1        ClearAll();
C51 COMPILER V9.52.0.0   PROCESS                                                           08/17/2016 10:12:55 PAGE 3   

 117   1        beSettingAddr = 0;
 118   1        //µØÖ·ÇåÁã
 119   1        address[0] = 0;   address[1] = 0;   address[2] = 0;
 120   1        SaveParaToBlock();
 121   1      }
 122          /*******************************************************************************
 123                      Êý¾Ý°üÐ£Ñé,²¢½«MODBUSµÄÊý¾Ý´æÈëcmdBuffer[]ÖÐ
 124            input:   none     
 125            output:  none 
 126            
 127          rBuffer[0]: ==> ADDR
 128          rBuffer[1]: ==> MODBUS¹¦ÄÜÂë
 129          rBuffer[2]: ==> ÆðÊ¼µØÖ·H
 130          rBuffer[3]: ==> ÆðÊ¼µØÖ·L
 131          rBuffer[4]: ==> ¼Ä´æÆ÷ÊýÁ¿H
 132          rBuffer[5]: ==> ¼Ä´æÆ÷ÊýÁ¿L
 133          
 134          0X03:
 135          rBuffer[6]: ==> CRCH
 136          rBuffer[7]: ==> CRCL
 137          
 138          0X10:
 139          rBuffer[6]: ==> 2
 140          rBuffer[7]: ==> 0/1
 141          rBuffer[8]: ==> XXXABCDE
 142          rBuffer[9]: ==> CRCH
 143          rBuffer[10]: ==> CRCL
 144          
 145          *******************************************************************************/
 146          UINT8 DiscodeProtocalV1(void)
 147          {
 148   1        UINT8 addr    = address[0] * 100 + address[1]*10 + address[2];
 149   1        UINT16 usCRC, retCRC;
 150   1        UINT8 lightTowerIndex = 0;
 151   1        UINT8 tempValue = 0;
 152   1        UINT8 index = 0,i=0;
 153   1        UINT16 usValue = 0; 
 154   1        //0ºÅ¹ã²¥ÃüÁîµØÖ·£¬²»Ðè»Ø¸´
 155   1        if(uart.rBuffer[0] == 0x00 && uart.rBuffer[1] == 0X06 && uart.rIndex == 8)  
 156   1        {
 157   2          LED_RXD485_ON;
 158   2          LED_TXD485_ON;
 159   2          //Send485SerialByte((UINT8 *)uart.rBuffer, uart.rIndex);  
 160   2          retCRC = CRC16    (uart.rBuffer, uart.rIndex-2);    //CRC
 161   2          retCRC=0;
 162   2          usCRC  = (UINT16) (uart.rBuffer [uart.rIndex-2]);   //CRC_L;
 163   2          usCRC += (UINT16) (uart.rBuffer [uart.rIndex-1]<<8);  //CRC_H
 164   2          if (retCRC == usCRC)            //crcÐ£Ñé³É¹¦ 
 165   2          {
 166   3            //00 06 ?? 00 ?? ?? CRCH CRCL
 167   3            if(uart.rBuffer[3] == 0X00)         //µØÖ·ÇåÁã
 168   3            {
 169   4              ResetAddr();
 170   4            }
 171   3            //00 06 ?? 01 ?? ## CRCH CRCL
 172   3            else if(uart.rBuffer[3] == 0X01)        //½ÓÊÕµØÖ·£¬²¢ÏÔÊ¾£¬½øÈëµÈ´ý°´¼üÈ·ÈÏ
 173   3            {
 174   4              if(beSettingAddr != 0X02)  //Ö»ÄÜÉèÖÃÒ»´ÎµØÖ·
 175   4              {
 176   5                beSettingAddr = 1;
 177   5                toSettedAddr[0] = (UINT8)(uart.rBuffer[5]/100);
 178   5                toSettedAddr[1] = (UINT8)(((UINT8)(uart.rBuffer[5]%100))/10);
C51 COMPILER V9.52.0.0   PROCESS                                                           08/17/2016 10:12:55 PAGE 4   

 179   5                toSettedAddr[2] = uart.rBuffer[5]%10;
 180   5                //ÉèÖÃ¸üÐÂÐÅÏ¢£¬ÏÔÊ¾µØÖ·Éè¶¨ÌáÊ¾
 181   5                led_flash_mode = LED_FLASH_MODE_ALWAYS; //³£ÁÁ
 182   5                led_flash_NO = LED_GREEN;       //½ÓÊÕÇ°ÁÁµÚÒ»×éµÆ£¬½ÓÊÕºóÁÁµÚ¶þ×éµÆ
 183   5              }
 184   4            }
 185   3            //00 06 ?? 11 ?? ?? CRCH CRCL
 186   3            else if(uart.rBuffer[3] == 0X11)        //¹ã²¥Çå³ý
 187   3            {
 188   4              ClearAll();
 189   4              beSettingAddr = 0;
 190   4            }
 191   3          }
 192   2          LED_RXD485_OFF;
 193   2          LED_TXD485_OFF;
 194   2        }
 195   1        //ÆäËüÍ¨ÐÅÃüÁî
 196   1        else if (uart.rBuffer[0] == addr)         //µØÖ·Ð£Ñé
 197   1        {
 198   2          LED_RXD485_ON;
 199   2          LED_TXD485_ON;
 200   2      
 201   2          retCRC = CRC16(uart.rBuffer, uart.rIndex-2);
 202   2          retCRC=0;
 203   2          usCRC  = (UINT16) (uart.rBuffer [uart.rIndex-2]);   //CRC_L;
 204   2          usCRC += (UINT16) (uart.rBuffer [uart.rIndex-1]<<8);  //CRC_H
 205   2      
 206   2          if (retCRC == usCRC)            //crcÐ£Ñé³É¹¦ 
 207   2          {
 208   3            switch (uart.rBuffer[1])
 209   3            {
 210   4            case READ_MULTI_BYTE: //ÖÕ¶ËÉÏ´«Êý¾Ý£¬¶ÁÈ¡É¨ÃèÇ¹
 211   4              {
 212   5                if((uart.rBuffer[4] == 0x00) && (uart.rBuffer[5] == 0x01))      //µØÖ·È·ÈÏ Ò²±»µ±×÷ÐÄÌøÐ­Òé
 213   5                {
 214   6                  ACK_Multi_ReadTestAddr();                   //µØÖ·Éè¶¨ÊÇ·ñ³É¹¦²âÊÔ
 215   6                }
 216   5                else if ((uart.rBuffer[4] == 0x00) && (uart.rBuffer[5] == 0x03))  //¼Ä´æÆ÷ÊýÁ¿03±íÊ¾¶ÁÈ¡ÊÇ·ñ°´OK¼üµÄÃü
             -Áî
 217   5                {                       
 218   6                  ACK_Multi_Read();                       //Ó¦´ðModbus 0x03ºÅ²É¼¯°´Å¥ÃüÁî
 219   6                }
 220   5                else if ((uart.rBuffer[4] == 0x00) && (uart.rBuffer[5] == 0x05))  //¼Ä´æÆ÷ÊýÁ¿05±íÊ¾¶ÁÈ¡É¨Ãèµ½µÄÌõÂëÐÅ
             -Ï¢
 221   5                {                       
 222   6                  ACK_Multi_Read();                       //Ó¦´ðModbus 0x03ºÅ²É¼¯°´Å¥ÃüÁî
 223   6                }
 224   5                break;
 225   5                  }
 226   4            case WRITE_SINGLE_BYTE: //¿ØÖÆÆ÷ÏÂ´«Êý¾Ý,0X06ºÅmodbusÃüÁî£ºÇåÆÁÃüÁî£»Çå³ý°´¼ü°´ÏÂÐÅÏ¢ÃüÁî
 227   4              {
 228   5                if(uart.rIndex == 0X08)           //ËùÓÐ06ºÅÃüÁî¶¼ÊÇ8×Ö½Ú³¤¶È
 229   5                {
 230   6                  ACK_Single_Write();
 231   6                  //Çå³ýÈ«²¿(Çå³ýÏÔÊ¾ÐÅÏ¢¡¢µÆ¡¢·äÃùÆ÷)£¬Çå³ýOKÐÅÏ¢+É¨ÃèÇ¹ÐÅÏ¢+µÆËþÐÅÏ¢
 232   6                  if(uart.rBuffer[3] == 0X00)
 233   6                  {
 234   7                    ClearAll();
 235   7                  }
 236   6                  //Çå³ýÏÔÊ¾²¿·Ö(Çå³ýÏÔÊ¾ÐÅÏ¢¡¢µÆ¡¢·äÃùÆ÷)£¬²»°üÀ¨£¬Çå³ýOKÐÅÏ¢+É¨ÃèÇ¹ÐÅÏ¢+µÆËþÐÅÏ¢
 237   6                  else if(uart.rBuffer[3] == 0X01 || uart.rBuffer[3] == 0X02)
 238   6                  {
C51 COMPILER V9.52.0.0   PROCESS                                                           08/17/2016 10:12:55 PAGE 5   

 239   7                    Display_Clear();
 240   7                  }
 241   6                  
 242   6                  else if(uart.rBuffer[3] == 0x05)//Çå³ýÉ¨ÃèÇ¹ÐÅÏ¢    
 243   6                  {
 244   7                          RC522_rFlag  = OFF;
 245   7                  }
 246   6                  //Çå³ýOK°´Å¥ÐÅÏ¢
 247   6                  else if(uart.rBuffer[3] == 0X10)      
 248   6                  {
 249   7                    IsOkPressed = FALSE;              
 250   7                  }
 251   6                  //Ëø¶¨½âËø
 252   6                  if(uart.rBuffer[3] == 0x20)       
 253   6                  {
 254   7                    if(uart.rBuffer[5] == 0x00)     //Ëø¶¨
 255   7                    {
 256   8                      SystemLocked = OFF;
 257   8                    }
 258   7                    else if(uart.rBuffer[5] == 0x01)  //½âËø
 259   7                    {
 260   8                      SystemLocked = ON;
 261   8                    }
 262   7                  }
 263   6                }
 264   5                break;
 265   5              }
 266   4            case WRITE_MULTI_BYTE:    //ÖÕ¶ËÏÂ´«Êý¾Ý    Çå³ýÒÑ¾­°´ÏÂµÄOKÐÅÏ¢
 267   4              {
 268   5                if (uart.rBuffer[8] == uart.rIndex-11 && uart.rBuffer[8] <= MAX_SRCODE_NUM) 
 269   5                {
 270   6                  ACK_Multi_Write();
 271   6                  //¿ªÊ¼´¦ÀíÃüÁî£¬°üÀ¨Êý¾ÝÔÝ´æ½ÓÊÕ¡¢¸÷ÖÖÏìÓ¦µÈ
 272   6                  //´Ë´¦Éý¼¶°æ±¾ÖÐÓ¦»ñÈ¡ÁÁµÆÄ£Ê½ uart.rBuffer[6]£¬·äÃùÆ÷Ä£Ê½ uart.rBuffer[7]
 273   6                  //uart.rBuffer[6]==>LEDÖ¸Ê¾µÆµÄÏÔÊ¾·½Ê½´¦Àí
 274   6                  //ÉÁË¸µÆÐòºÅ
 275   6                    led_flash_NO   = (uart.rBuffer[6] >> 5)&0X07;
 276   6                  //ÉÁË¸Ê±¼ä¼ä¸ô
 277   6                  switch((uart.rBuffer[6] >> 3)&0X3)
 278   6                  {
 279   7                  case 0:   led_flash_period = 80;    break;
 280   7                  case 1:   led_flash_period = 160;   break;
 281   7                  case 2:   led_flash_period = 320;   break;
 282   7                  case 3:   led_flash_period = 640;   break;
 283   7                  default:  led_flash_period = 640;   break;
 284   7                  }
 285   6                  //ÉÁË¸Ä£Ê½
 286   6                    led_flash_mode   = (uart.rBuffer[6] >> 0)&0X07;
 287   6                  //ÉÁË¸ÓÃÊý¾ÝÖÃÎ»
 288   6                  led_flash_status = 0;
 289   6                  sys.led_flash_count = 0;
 290   6                }
 291   5                break;
 292   5              }
 293   4            default:
 294   4              {
 295   5                break;
 296   5              }
 297   4            }
 298   3          }
 299   2          LED_RXD485_OFF;
 300   2          LED_TXD485_OFF;
C51 COMPILER V9.52.0.0   PROCESS                                                           08/17/2016 10:12:55 PAGE 6   

 301   2        }
 302   1        for(i=0;i<50;i++)
 303   1        {
 304   2          uart.rBuffer[i]=0;
 305   2        } 
 306   1        uart.rIndex = 0;
 307   1        uart.rFlag  = OFF;
 308   1      
 309   1        return OK;
 310   1      }
 311          
 312          /*******************************************************************************
 313                      ´¦ÀíMODBUS×ÜÕ¾ÏÂ·¢µÄÃüÁî
 314          0X03ÃüÁî:  ¹¦ÄÜÂë             =>  1 BYTE  (0X03)
 315                                  ÆðÊ¼µØÖ·      =>   2 BYTE (0X0000~0XFFFF)
 316                                  ¼Ä´æÆ÷ÊýÁ¿=>   2 BYTE (1~125)                       
 317          
 318          0X10ÃüÁî:  ¹¦ÄÜÂë             =>   1 BYTE (0X10)
 319                                  ÆðÊ¼µØÖ·      =>   2 BYTE (0X0000~0XFFFF)
 320                                  ¼Ä´æÆ÷ÊýÁ¿=>   2 BYTE (1~120)
 321                                  ×Ö½ÚÊý            =>   1 BYTE (2 )
 322                                  ¼Ä´æÆ÷Êý1    =>   1 BYTE  ==> ÊÇ·ñÇëÌõÐÎÂë»º³åÇø,0²»Çå,1Çå³ý
 323                                  ¼Ä´æÆ÷Êý2    =>   1 BYTE  ==> Êä³ö5¸öLEDµÈ¿ØÖÆ×´Ì¬
 324                                                                                             //xxxabcdef => 0~4bit ´
             -ú±íµÆµÄ¿ª¹Ø×´Ì¬
 325          *******************************************************************************/
 326          void Cmd_Process(void)
 327          {
 328   1          //Êý¾Ý°ü³¤¶È²»¹»
 329   1        if (uart.rIndex < ONE_CMD_MIN_LENGTH)
 330   1          return;       
 331   1          //ÏÈ¿´µØÖ·¡¢CRCÐ£Ñé¡¢Êý¾Ý³¤¶ÈµÈÅÐ¶Ï
 332   1        //ÔÙ¸ù¾ÝµÚ¶þ¸ö×Ö½ÚµÄ·¶Î§ÅÐ¶ÏÊÇ²ÉÓÃÐÂÐ­Òé½âÎö»¹ÊÇ¾ÉÐ­Òé½âÎö
 333   1        //µØÖ·ÓëCRCÊý¾ÝÐ£Ñé,ÏÂ´«Ö¸Áî´æ´¢,MODBUSÓ¦´ð,CRC_Checkº¯ÊýÖÐ°üº¬µØÖ·Éè¶¨ÃüÁî
 334   1        DiscodeProtocalV1();
 335   1      }
 336          /*******************************************************************************
 337                          END         
 338          *******************************************************************************/
 339          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1188    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
